# 参数（与题面一致）
p = int("""1109330043876535778769382312206850193332682918151869365089709078
1749379503427651954028543076247583697669597230934286751428880673
539155279232304301123931419""".replace("\n",""))
a = int("""4909634341535158829344879731851428423571755230081832922968151406
9899905465877782055607679449041461073765436580706391660203781695
5706321036900113929329671""".replace("\n",""))
b = int("""7668542654793784988436499086739239442915170287346121645884096222
9483382791653022134400600791419606796785260163480250295583359770
42712382611197995002316466""".replace("\n",""))
Gx = int("""8446393446547201418334284268653589214141709401353823691233474538
3953221277118124581535396186950559697605585406266206226853927978
44451273389238413721853040""".replace("\n",""))
Gy = int("""2021254579885108358847006646568878947160366238515762141220069590
1109006149293894017755963172207531128893505583364983702929711850
18132761788548744858527373""".replace("\n",""))
Qx = int("""3946232918905341150335730775965812293761462634639965260659576338
8264874246412345534284496568764197358749470089464636757482627140
50903634293001729551902233""".replace("\n",""))
Qy = int("""4491653246723554932897915923426408951541365920364127841395067677
9600935417899705325845037300177316803431379617411341833354197798
6445469508389555398056443""".replace("\n",""))
G, Q = (Gx, Gy), (Qx, Qy)

def eg_inv(n, m):
    # 扩展欧几里得求逆
    a0, b0, x0, x1 = m, n % m, 0, 1
    while b0:
        q = a0 // b0
        a0, b0, x0, x1 = b0, a0 - q*b0, x1, x0 - q*x1
    if a0 != 1:
        raise ValueError("not invertible")
    return x0 % m

def ec_add(P, Q, A, mod):
    if P is None: return Q
    if Q is None: return P
    x1,y1 = P; x2,y2 = Q
    if (x1-x2) % mod == 0 and (y1+y2) % mod == 0:
        return None
    if P != Q:
        lam = ((y2 - y1) * eg_inv((x2 - x1) % mod, mod)) % mod
    else:
        lam = ((3*x1*x1 + A) * eg_inv((2*y1) % mod, mod)) % mod
    x3 = (lam*lam - x1 - x2) % mod
    y3 = (lam*(x1 - x3) - y1) % mod
    return (x3, y3)

def ec_mul(k, P, A, mod):
    R, Qp = None, P
    while k:
        if k & 1: R = ec_add(R, Qp, A, mod)
        Qp = ec_add(Qp, Qp, A, mod)
        k >>= 1
    return R

def sssa_recover_d(p, a, b, G, Q):
    x1,y1 = G; x2,y2 = Q
    mod = p*p
    # 简单提升：x 不变，y 加 p（保持到某条模 p^2 的曲线上）
    y1l = y1 + p; y2l = y2 + p
    # 解出提升后的 A2,B2 使两点都落在 y^2 = x^3 + A2 x + B2 (mod p^2)
    A2 = ((y2l*y2l - y1l*y1l - ((x2**3 - x1**3) % mod)) * eg_inv((x2 - x1) % mod, mod)) % mod
    B2 = (y1l*y1l - (x1**3 % mod) - A2*x1) % mod
    # 计算 (p-1) 倍点，并比较与原坐标的“p 级偏移”
    G2 = (x1 % mod, y1l % mod)
    Q2 = (x2 % mod, y2l % mod)
    g2s = ec_mul(p-1, G2, A2, mod)
    q2s = ec_mul(p-1, Q2, A2, mod)
    dx1 = (g2s[0] - x1) // p
    dx2 = (q2s[0] - x2) // p
    dy1 = (g2s[1] - y1l)
    dy2 = (q2s[1] - y2l)
    # d ≡ (dy1/dx1) * (dx2/dy2) (mod p)
    return (dy1 * pow(dx1, -1, p) * dx2 * pow(dy2, -1, p)) % p

d = sssa_recover_d(p, a, b, G, Q)


# 复原明文
import hashlib
K = hashlib.sha256(str(d).encode()).digest()
ct = bytes.fromhex("a81846ee8f1e03434dc437040b858207d265dff9b573341854b893f391068f7dfd1611bac400")
ks = (K * ((len(ct)+len(K)-1)//len(K)))[:len(ct)]
pt = bytes([c ^ k for c,k in zip(ct, ks)])
print(pt.decode())
